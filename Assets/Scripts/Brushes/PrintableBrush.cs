// Copyright 2020 The Tilt Brush Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using UnityEngine;

namespace TiltBrush {

class PrintableBrush : GeometryBrush {
  protected const int BR = 0;   // back  right
  protected const int BL = 1;   // back  left
  protected const int BT = 2;   // back  top
  protected const int BB = 3;   // back  bottom
  protected const int FR = 4;   // front right
  protected const int FL = 5;   // front left
  protected const int FT = 6;   // front top
  protected const int FB = 7;   // front bottom

  const float kSolidMinLengthMeters_PS = 0.002f;
  const float kMinMoveLengthMeters_PS = 5e-4f;
  const float kBreakAngleScalar = 2.0f;
  const float kSolidAspectRatio = 0.2f;
  const float kCrossSectionAspectRatio = .375f;  // height / width

  public bool m_UseEnvelope = false;

  public PrintableBrush()
    : base(bCanBatch: true,
           upperBoundVertsPerKnot: 4,
           bDoubleSided: false) {
  }

  //
  // GeometryBrush API
  //

  protected override void InitBrush(BrushDescriptor desc,
      TrTransform localPointerXf) {
    base.InitBrush(desc, localPointerXf);
    m_geometry.Layout = GetVertexLayout(desc);
  }

  override public GeometryPool.VertexLayout GetVertexLayout(BrushDescriptor desc) {
    return new GeometryPool.VertexLayout {
      // Don't use UVs, but don't want to write another shader that doesn't sample
      uv0Size = 2,
      bUseNormals = true,
      bUseColors = true,
    };
  }

  override public float GetSpawnInterval(float pressure01) {
    return kSolidMinLengthMeters_PS * POINTER_TO_LOCAL * App.METERS_TO_UNITS +
      (PressuredSize(pressure01) * kSolidAspectRatio);
  }

  override protected void ControlPointsChanged(int iKnot0) {
    // Frames knots, determines how much geometry each knot should get
    OnChanged_FrameKnots(iKnot0);
    OnChanged_SetEnvelope(iKnot0);
    ResizeGeometry();

    // Updating a control point affects geometry generated by previous knot
    // (if there is any). The HasGeometry check is not a micro-optimization:
    // it also keeps us from backing up past knot 0.
    {
      int start = (m_knots[iKnot0 - 1].HasGeometry) ? iKnot0 - 1 : iKnot0;
      OnChanged_MakeGeometry(start);
    }
  }

  void SetKnotEnvelope(int i, float width) {
    Knot k = m_knots[i];
    k.qFrame.x = width;
    m_knots[i] = k;
  }

  const float kInitialEnvelope = .8f;
  const float kFinalEnvelope = .3f;
  // To approximate the shape of the tapered marker with geometry, calculate
  // an envelope. Envelope of the first knot is .8.  The _second_ through end
  // knots lerp from 1 down to .3.
  void OnChanged_SetEnvelope(int iKnot0) {
    int i0 = 0;
    int n = m_knots.Count;
    while (i0 < n) {
      // Find the longest span of non-break knots.
      int i1 = i0 + 1;
      float totalLength = 0;
      for ( ; i1 < n && m_knots[i1].HasGeometry; ++i1) {
        totalLength += m_knots[i1].length;
      }

      // Invariant: i0 is a break
      // Invariant: i1 > i0 and is also a break
      // Invariant: [i0, i1) are non-breaks (except for i0)

      SetKnotEnvelope(i0, kInitialEnvelope);

      if (i0 + 1 < i1) {
        // Chop off the first length, because the lerp starts at the second knot
        totalLength -= m_knots[i0+1].length;
        SetKnotEnvelope(i0 + 1, 1f);

        float curLength = 0;
        for (int i = i0 + 2; i < i1; ++i) {
          curLength += m_knots[i].length;
          // choose t=1 for the degenerate case of 0/0
          float t = (curLength >= totalLength) ? 1f : curLength / totalLength;
          SetKnotEnvelope(i, 1 * (1-t) + kFinalEnvelope * t);
        }
      }

      i0 = i1;
    }
  }

  // Fills in any knot data needed for geometry generation. Updates:
  // - length, nRight, nSurface
  // - HasGeometry, startsGeometry, endsGeometry
  // - iVert, nVert, iTri, nTri
  void OnChanged_FrameKnots(int iKnot0) {
    float minMove = kMinMoveLengthMeters_PS * App.METERS_TO_UNITS * POINTER_TO_LOCAL;

    Knot prev = m_knots[iKnot0-1];
    for (int iKnot = iKnot0; iKnot < m_knots.Count; ++iKnot) {
      Knot cur = m_knots[iKnot];

      bool shouldBreak = false;

      Vector3 vMove = cur.point.m_Pos - prev.point.m_Pos;
      cur.length = vMove.magnitude;

      // Rather than use unstable math, just bail and don't change the geometry.
      if (cur.length < minMove) {
        // nb. it's only safe to bail if we haven't already started changing state
        // (thus the assert that this is the last knot). We also only expect this to
        // happen for the dynamic leading edge (thus the assert that this is the first
        // knot in the update list).
        shouldBreak = true;
      }

      // invariant: nSurface = nMove x nRight
      // If single-sided, always point the frontside towards the brush. Causes twisting.
      Vector3 nMove = vMove / cur.length;
      Vector3 vPreferredRight = m_Desc.m_BackIsInvisible
        ? Vector3.Cross(cur.point.m_Orient * Vector3.forward, nMove)
        : prev.nRight;
      ComputeSurfaceFrameNew(
          vPreferredRight, nMove, cur.point.m_Orient,
          out cur.nRight, out cur.nSurface);

      // More break checking; replicates previous logic
      if (prev.HasGeometry) {
        float fWidthHeightRatio = cur.length / PressuredSize(cur.smoothedPressure);
        float fBreakAngle = Mathf.Atan(fWidthHeightRatio) * Mathf.Rad2Deg * kBreakAngleScalar;
        Vector3 vPrevMove = prev.point.m_Pos - m_knots[iKnot-2].point.m_Pos;
        if (Vector3.Angle(vPrevMove, vMove) > fBreakAngle) {
          shouldBreak = true;
        }
      }

      if (shouldBreak) {
        // These things are documented as being invalid unless HasGeometry,
        // so technically we don't need to null them out
        cur.nRight = cur.nSurface = Vector3.zero;
        cur.startsGeometry = cur.endsGeometry = false;

        // nb: duplicated down below too
        if (prev.HasGeometry && !prev.endsGeometry) {
          prev.endsGeometry = true;
          prev.nTri += 2;
          m_knots[iKnot-1] = prev;
        }

        cur.iTri = prev.iTri + prev.nTri;
        cur.iVert = (ushort)(prev.iVert + prev.nVert);
        cur.nTri = cur.nVert = (ushort)0;
      } else {
        if (prev.HasGeometry && prev.endsGeometry) {
          prev.endsGeometry = false;
          prev.nTri -= 2;
          m_knots[iKnot-1] = prev;
        }

        cur.startsGeometry = !prev.HasGeometry;
        cur.endsGeometry = false;  // this will be fixed up next iteration
        cur.nVert = 8;
        cur.nTri = 8;
        cur.iTri = prev.iTri + prev.nTri;
        if (cur.startsGeometry) {
          // no shared verts with previous.
          // 2 extra triangles for start cap.
          cur.iVert = (ushort)(prev.iVert + prev.nVert);
          cur.nTri += 2;
        } else {
          // 4 shared verts with previous.
          cur.iVert = (ushort)(prev.iVert + prev.nVert - 4);
        }
      }

      m_knots[iKnot] = cur;
      prev = cur;
    }

    // nb: copied from the loop
    if (prev.HasGeometry && !prev.endsGeometry) {
      prev.endsGeometry = true;
      prev.nTri += 2;
      m_knots[m_knots.Count-1] = prev;
    }
  }

  // Create verts, tris
  void OnChanged_MakeGeometry(int iKnot0) {

    // Invariant: there is a previous knot.
    Knot prev = m_knots[iKnot0-1];

    for (int iKnot = iKnot0; iKnot < m_knots.Count; ++iKnot) {
      // Invariant: all of prev's geometry (if any) is correct and up-to-date.
      // Thus, there is no need to modify anything shared with prev.
      Knot cur = m_knots[iKnot];

      if (cur.HasGeometry) {
        int nTri = 0;

        // Top quads
        SetTri(cur.iTri, cur.iVert, nTri++, BT, BL, FT);
        SetTri(cur.iTri, cur.iVert, nTri++, FT, BL, FL);
        SetTri(cur.iTri, cur.iVert, nTri++, BT, FT, BR);
        SetTri(cur.iTri, cur.iVert, nTri++, BR, FT, FR);
        // Bottom quads
        SetTri(cur.iTri, cur.iVert, nTri++, BB, FB, BL);
        SetTri(cur.iTri, cur.iVert, nTri++, BL, FB, FL);
        SetTri(cur.iTri, cur.iVert, nTri++, BB, BR, FB);
        SetTri(cur.iTri, cur.iVert, nTri++, FB, BR, FR);
        // Endcaps
        if (cur.startsGeometry) {
          SetTri(cur.iTri, cur.iVert, nTri++, BT, BR, BL);
          SetTri(cur.iTri, cur.iVert, nTri++, BL, BR, BB);
        }
        if (cur.endsGeometry) {
          SetTri(cur.iTri, cur.iVert, nTri++, FT, FL, FR);
          SetTri(cur.iTri, cur.iVert, nTri++, FR, FL, FB);
        }
        Debug.Assert(nTri == cur.nTri);

        if (cur.startsGeometry) {
          // Can't use prev.nRight, prev.nSurface; they're invalid if no geometry
          float size = PressuredSize(prev.smoothedPressure) * prev.qFrame.x;
          Vector3 halfR = cur.nRight * (size / 2);
          Vector3 halfU = cur.nSurface * ((size / 2) * kCrossSectionAspectRatio);
          MySetVert(cur.iVert, BR, prev.point.m_Pos + halfR,  cur.nRight);
          MySetVert(cur.iVert, BL, prev.point.m_Pos - halfR, -cur.nRight);
          MySetVert(cur.iVert, BT, prev.point.m_Pos + halfU,  cur.nSurface);
          MySetVert(cur.iVert, BB, prev.point.m_Pos - halfU, -cur.nSurface);
        }

        {
          float size = PressuredSize(cur.smoothedPressure) * cur.qFrame.x;
          Vector3 halfR = cur.nRight * (size / 2);
          Vector3 halfU = cur.nSurface * ((size / 2) * kCrossSectionAspectRatio);
          MySetVert(cur.iVert, FR, cur.point.m_Pos + halfR,  cur.nRight);
          MySetVert(cur.iVert, FL, cur.point.m_Pos - halfR, -cur.nRight);
          MySetVert(cur.iVert, FT, cur.point.m_Pos + halfU,  cur.nSurface);
          MySetVert(cur.iVert, FB, cur.point.m_Pos - halfU, -cur.nSurface);
        }
      }

      prev = cur;
    }
  }

  void MySetVert(int iVert, int vp, Vector3 v, Vector3 n) {
    int i = iVert + vp * NS;
    m_geometry.m_Vertices[i] = v;
    m_geometry.m_Normals[i] = n;
    Color32 c = m_Color;
    c.a = 255;
    m_geometry.m_Colors[i] = c;
    m_geometry.m_Texcoord0.v2[i] = new Vector2(.5f, .5f);
  }

}
}  // namespace TiltBrush
